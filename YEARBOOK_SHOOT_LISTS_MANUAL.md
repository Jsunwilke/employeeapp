# Yearbook Shoot Lists - iOS Integration Manual

## Overview

The Yearbook Shoot Lists feature allows photography studios to create and manage comprehensive checklists of required photos for school yearbooks. Each school can have multiple yearbook lists (one per school year), and photographers can mark items as completed during their sessions.

## Table of Contents

1. [Data Structure](#data-structure)
2. [Firestore Schema](#firestore-schema)
3. [Core Functionality](#core-functionality)
4. [Security Rules](#security-rules)
5. [API Operations](#api-operations)
6. [Integration with Sessions](#integration-with-sessions)
7. [iOS Implementation Guide](#ios-implementation-guide)
8. [Caching Strategy](#caching-strategy)

## Data Structure

### Collection: `yearbookShootLists`

Each document represents a yearbook shoot list for a specific school and school year.

#### Document Structure:

```javascript
{
  // Identification
  organizationId: string,      // Organization that owns this list
  schoolId: string,           // Reference to school document
  schoolName: string,         // School name (denormalized for performance)
  schoolYear: string,         // Format: "2024-2025"
  
  // Date Range
  startDate: timestamp,       // August 1st of start year
  endDate: timestamp,         // July 31st of end year
  isActive: boolean,          // True if current school year
  
  // Metadata
  copiedFromId: string?,      // If copied from another list/template
  completedCount: number,     // Number of completed items
  totalCount: number,         // Total number of items
  
  // Items Array
  items: [{
    id: string,               // Unique item identifier
    name: string,             // Item name (e.g., "Team Photo")
    description: string?,     // Optional description
    category: string,         // Category name (e.g., "Sports", "Academics")
    required: boolean,        // Whether this item is required
    completed: boolean,       // Completion status
    completedDate: timestamp?, // When completed
    completedBySession: string?, // Session ID that completed this
    photographerId: string?,   // Photographer who completed
    photographerName: string?, // Photographer name (denormalized)
    imageNumbers: string[]?,   // Array of image numbers/references
    notes: string?,           // Additional notes
    order: number             // Display order within category
  }],
  
  // Timestamps
  createdAt: timestamp,
  updatedAt: timestamp
}
```

## Firestore Schema

### Document ID Pattern
- Auto-generated by Firestore
- No specific naming convention required

### Indexes Required
1. Composite index: `organizationId` + `schoolYear` (for organization-wide queries)
2. Composite index: `schoolId` + `schoolYear` (for school-specific queries)
3. Single field index: `updatedAt` (for cache optimization)

## Core Functionality

### 1. School Year Calculation

The system automatically calculates school years based on dates:

```swift
func getCurrentSchoolYear(date: Date = Date()) -> String {
    let calendar = Calendar.current
    let year = calendar.component(.year, from: date)
    let month = calendar.component(.month, from: date)
    
    // School year starts in August (month 8)
    if month >= 8 {
        // August-December: return current year - next year
        return "\(year)-\(year + 1)"
    } else {
        // January-July: return previous year - current year
        return "\(year - 1)-\(year)"
    }
}
```

### 2. Creating a Shoot List

When creating a new shoot list:
- Automatically set date range based on school year
- Mark as active if it's the current school year
- Initialize all items as uncompleted
- Set completedCount to 0

### 3. Managing Items

Items are organized by categories and can be:
- Marked as completed/uncompleted
- Updated with photographer info when completed
- Linked to specific sessions
- Annotated with notes and image numbers

### 4. Completion Tracking

When marking an item complete:
- Set `completed = true`
- Record `completedDate` (current timestamp)
- Store `photographerId` and `photographerName`
- Optionally store `completedBySession` (session reference)
- Update parent document's `completedCount`

## Security Rules

```javascript
match /yearbookShootLists/{listId} {
  // Read: Users in same organization
  allow read: if request.auth != null && 
                 belongsToSameOrg(request.auth.uid, resource.data.organizationId);
  
  // Create: Admins and photographers in same organization
  allow create: if request.auth != null && 
                   belongsToSameOrg(request.auth.uid, request.resource.data.organizationId) &&
                   (isAdmin(request.auth.uid) || getUserRole(request.auth.uid) == 'photographer');
  
  // Update: Admins and photographers in same organization
  allow update: if request.auth != null && 
                   belongsToSameOrg(request.auth.uid, resource.data.organizationId) &&
                   (isAdmin(request.auth.uid) || getUserRole(request.auth.uid) == 'photographer');
  
  // Delete: Only admins in same organization
  allow delete: if request.auth != null && 
                   isAdmin(request.auth.uid) &&
                   belongsToSameOrg(request.auth.uid, resource.data.organizationId);
}
```

## API Operations

### 1. Get Shoot List for School/Year

```swift
func getYearbookShootList(schoolId: String, schoolYear: String) async throws -> YearbookShootList? {
    let db = Firestore.firestore()
    
    let snapshot = try await db.collection("yearbookShootLists")
        .whereField("schoolId", isEqualTo: schoolId)
        .whereField("schoolYear", isEqualTo: schoolYear)
        .limit(to: 1)
        .getDocuments()
    
    guard let document = snapshot.documents.first else {
        return nil
    }
    
    return try document.data(as: YearbookShootList.self)
}
```

### 2. Get Available Years for School

```swift
func getAvailableYears(schoolId: String) async throws -> [String] {
    let db = Firestore.firestore()
    
    let snapshot = try await db.collection("yearbookShootLists")
        .whereField("schoolId", isEqualTo: schoolId)
        .getDocuments()
    
    let years = snapshot.documents.compactMap { doc in
        doc.data()["schoolYear"] as? String
    }
    
    return Array(Set(years)).sorted(by: >)
}
```

### 3. Update Item Completion

```swift
func updateShootListItem(listId: String, itemId: String, updates: [String: Any]) async throws {
    let db = Firestore.firestore()
    let listRef = db.collection("yearbookShootLists").document(listId)
    
    // Get current document
    let document = try await listRef.getDocument()
    guard var listData = document.data(),
          var items = listData["items"] as? [[String: Any]] else {
        throw YearbookError.listNotFound
    }
    
    // Find and update item
    if let index = items.firstIndex(where: { ($0["id"] as? String) == itemId }) {
        items[index].merge(updates) { _, new in new }
        
        // Update completed count if status changed
        let wasCompleted = items[index]["completed"] as? Bool ?? false
        let isNowCompleted = updates["completed"] as? Bool ?? wasCompleted
        
        if wasCompleted != isNowCompleted {
            let currentCount = listData["completedCount"] as? Int ?? 0
            listData["completedCount"] = isNowCompleted ? currentCount + 1 : max(0, currentCount - 1)
        }
    }
    
    // Update document
    try await listRef.updateData([
        "items": items,
        "completedCount": listData["completedCount"] ?? 0,
        "updatedAt": FieldValue.serverTimestamp()
    ])
}
```

### 4. Real-time Listener

```swift
func subscribeToShootListUpdates(schoolId: String, schoolYear: String, 
                                completion: @escaping (YearbookShootList?) -> Void) -> ListenerRegistration {
    let db = Firestore.firestore()
    
    return db.collection("yearbookShootLists")
        .whereField("schoolId", isEqualTo: schoolId)
        .whereField("schoolYear", isEqualTo: schoolYear)
        .limit(to: 1)
        .addSnapshotListener { snapshot, error in
            guard let document = snapshot?.documents.first else {
                completion(nil)
                return
            }
            
            let shootList = try? document.data(as: YearbookShootList.self)
            completion(shootList)
        }
}
```

## Integration with Sessions

### When Opening a Session:

1. Calculate the school year based on session date
2. Load the yearbook shoot list for that school/year
3. Allow photographers to view and mark items complete
4. Auto-fill completion data with session context

### Session Context Data:

When marking items complete from a session, include:
- `completedBySession`: session ID
- `photographerId`: assigned photographer
- `photographerName`: photographer's display name
- `completedDate`: session date (or current date)

## iOS Implementation Guide

### 1. Data Models

```swift
struct YearbookShootList: Codable {
    @DocumentID var id: String?
    let organizationId: String
    let schoolId: String
    let schoolName: String
    let schoolYear: String
    let startDate: Timestamp
    let endDate: Timestamp
    let isActive: Bool
    let copiedFromId: String?
    var completedCount: Int
    let totalCount: Int
    var items: [YearbookItem]
    let createdAt: Timestamp
    var updatedAt: Timestamp
}

struct YearbookItem: Codable {
    let id: String
    let name: String
    let description: String?
    let category: String
    let required: Bool
    var completed: Bool
    var completedDate: Timestamp?
    var completedBySession: String?
    var photographerId: String?
    var photographerName: String?
    var imageNumbers: [String]?
    var notes: String?
    let order: Int
}
```

### 2. View Model Example

```swift
class YearbookShootListViewModel: ObservableObject {
    @Published var shootList: YearbookShootList?
    @Published var loading = false
    @Published var error: Error?
    
    private var listener: ListenerRegistration?
    
    func loadShootList(schoolId: String, schoolYear: String) {
        loading = true
        
        listener = subscribeToShootListUpdates(schoolId: schoolId, schoolYear: schoolYear) { [weak self] list in
            self?.shootList = list
            self?.loading = false
        }
    }
    
    func toggleItemCompletion(itemId: String, sessionContext: SessionContext?) async {
        guard let listId = shootList?.id,
              let item = shootList?.items.first(where: { $0.id == itemId }) else { return }
        
        var updates: [String: Any] = [
            "completed": !item.completed,
            "completedDate": !item.completed ? Timestamp() : NSNull(),
            "photographerId": !item.completed ? Auth.auth().currentUser?.uid ?? NSNull() : NSNull(),
            "photographerName": !item.completed ? sessionContext?.photographerName ?? "Unknown" : NSNull()
        ]
        
        if let sessionId = sessionContext?.sessionId, !item.completed {
            updates["completedBySession"] = sessionId
        }
        
        do {
            try await updateShootListItem(listId: listId, itemId: itemId, updates: updates)
        } catch {
            self.error = error
        }
    }
    
    deinit {
        listener?.remove()
    }
}
```

### 3. UI Components

```swift
struct YearbookChecklistView: View {
    @StateObject private var viewModel = YearbookShootListViewModel()
    let schoolId: String
    let schoolYear: String
    let sessionContext: SessionContext?
    
    var body: some View {
        NavigationView {
            if viewModel.loading {
                ProgressView()
            } else if let shootList = viewModel.shootList {
                List {
                    ForEach(groupedItems, id: \.key) { category, items in
                        Section(header: Text(category)) {
                            ForEach(items) { item in
                                YearbookItemRow(
                                    item: item,
                                    onToggle: {
                                        Task {
                                            await viewModel.toggleItemCompletion(
                                                itemId: item.id,
                                                sessionContext: sessionContext
                                            )
                                        }
                                    }
                                )
                            }
                        }
                    }
                }
                .navigationTitle("Yearbook Checklist")
                .navigationBarSubtitle("\(shootList.schoolName) • \(schoolYear)")
            } else {
                Text("No yearbook checklist found")
            }
        }
        .onAppear {
            viewModel.loadShootList(schoolId: schoolId, schoolYear: schoolYear)
        }
    }
    
    var groupedItems: [(key: String, value: [YearbookItem])] {
        Dictionary(grouping: viewModel.shootList?.items ?? [], by: { $0.category })
            .sorted { $0.key < $1.key }
    }
}
```

## Caching Strategy

### Local Storage

1. Cache shoot lists in UserDefaults or Core Data
2. Key format: `yearbook_\(schoolId)_\(schoolYear)`
3. Cache expiration: 7 days or on app launch
4. Always show cached data first, then update from server

### Offline Support

1. Enable Firestore offline persistence
2. Queue item updates when offline
3. Sync automatically when connection restored
4. Show offline indicator in UI

### Performance Optimization

1. Load only current year by default
2. Lazy load previous years on demand
3. Use pagination for very large item lists (>100 items)
4. Minimize real-time listener scope

## Best Practices

1. **Always validate school year format** ("YYYY-YYYY")
2. **Handle timezone properly** for date calculations
3. **Implement optimistic UI updates** for better UX
4. **Show completion progress** visually (progress bars, percentages)
5. **Group items by category** for better organization
6. **Allow filtering** by completion status
7. **Support search** within items
8. **Export functionality** for completed checklists

## Error Handling

Common errors to handle:
- Network connectivity issues
- Permission denied (user not in organization)
- Document not found (no list for school/year)
- Concurrent update conflicts
- Invalid data format

## Migration Considerations

If migrating from another system:
1. Batch import via Cloud Functions
2. Validate data integrity
3. Preserve historical completion data
4. Map categories consistently
5. Generate proper IDs for items