rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to get user's organization ID
    function getUserOrg(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.organizationID;
    }
    
    // Helper function to get user's role
    function getUserRole(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.role;
    }
    
    // Helper function to check if user is admin
    function isAdmin(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.role == 'admin';
    }
    
    // Helper function to check if user is admin or manager
    function isAdminOrManager(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      let role = userDoc.data.role;
      return role == 'admin' || role == 'manager';
    }
    
    // Helper function to check if user belongs to same organization
    function belongsToSameOrg(userId, orgId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.organizationID == orgId;
    }
    
    // Helper function to validate PTO document ID format and ownership
    function isValidPTODocumentAccess(balanceId, userId) {
      // Check if document ID follows pattern: orgId_userId
      let idParts = balanceId.split('_');
      return idParts.size() == 2 && idParts[1] == userId;
    }
    
    // Helper function to check if user is a participant in a conversation
    function isConversationParticipant(userId, conversationDoc) {
      return userId in conversationDoc.data.participants;
    }
    

    // Organizations collection
    match /organizations/{orgId} {
      // Users can read their own organization
      allow read: if request.auth != null && belongsToSameOrg(request.auth.uid, orgId);
      
      // **INVITATION FLOW: Allow reading specific organization for invitation display**
      // This is needed when showing organization name on invitation acceptance page
      allow read: if request.auth == null || request.auth != null;
      
      // Only authenticated users can create organizations (during studio signup)
      allow create: if request.auth != null;
      
      // Only admins can update their organization
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, orgId) && 
                       isAdmin(request.auth.uid) &&
                       // Validate PTO settings if being updated
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['ptoSettings']) ||
                        (request.resource.data.ptoSettings is map &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['enabled']) || request.resource.data.ptoSettings.enabled is bool) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['accrualRate']) || request.resource.data.ptoSettings.accrualRate is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['accrualPeriod']) || request.resource.data.ptoSettings.accrualPeriod is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['maxAccrual']) || request.resource.data.ptoSettings.maxAccrual is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['rolloverPolicy']) || request.resource.data.ptoSettings.rolloverPolicy in ['none', 'unlimited', 'limited']) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['rolloverLimit']) || request.resource.data.ptoSettings.rolloverLimit is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['resetDate']) || request.resource.data.ptoSettings.resetDate is string) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['yearlyAllotment']) || request.resource.data.ptoSettings.yearlyAllotment is number)));
      
      // No deletes allowed
      allow delete: if false;
    }

    // Users collection
    match /users/{userId} {
      // Users can read their own profile
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Users in same organization can read each other (for team management)
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // **INVITATION FLOW: Allow reading inactive users for invitation lookup**
      allow read: if resource.data.isActive == false;
      
      // **INVITATION FLOW: Allow reading temporary invite documents**
      allow read: if resource.data.keys().hasAny(['isTemporaryInvite']) && 
                     resource.data.isTemporaryInvite == true;
      
      // Users can create their own profile (during signup)
      allow create: if request.auth != null && request.auth.uid == userId;
      
      // **INVITATION FLOW: Admins can create temporary invite documents**
      allow create: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       (
                         // Regular user creation (document ID matches Firebase UID)
                         userId == request.auth.uid ||
                         // Temporary invite creation (document ID starts with "invite_")
                         (userId.matches('invite_.*') &&
                          request.resource.data.isTemporaryInvite == true &&
                          request.resource.data.isActive == false &&
                          request.resource.data.keys().hasAll(['email', 'firstName', 'lastName', 'role', 'organizationID', 'isTemporaryInvite', 'isActive']))
                       );
      
      // **INVITATION FLOW: Allow creating new user document during acceptance**
      allow create: if request.auth != null && 
                       request.auth.uid == userId &&
                       // This is a new Firebase Auth user accepting an invitation
                       request.resource.data.isActive == true &&
                       (!request.resource.data.keys().hasAny(['isTemporaryInvite']) || 
                        request.resource.data.isTemporaryInvite == false);
      
      // Users can update their own profile
      allow update: if request.auth != null && 
                       request.auth.uid == userId &&
                       (
                         // Allow users to update only their FCM token
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['fcmToken', 'fcmTokenUpdatedAt']) &&
                          request.resource.data.role == resource.data.role &&
                          request.resource.data.organizationID == resource.data.organizationID) ||
                         // Regular profile updates (existing rule)
                         (request.resource.data.role == resource.data.role &&
                          request.resource.data.organizationID == resource.data.organizationID &&
                          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['fcmToken', 'fcmTokenUpdatedAt']))
                       );
      
      // Admins can update users in their organization
      allow update: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // Admins and Managers can flag/unflag users in their organization
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Only allow updating flag-related fields
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isFlagged', 'flagNote', 'flaggedBy']) &&
                       // Prevent changing core fields
                       request.resource.data.organizationID == resource.data.organizationID &&
                       request.resource.data.role == resource.data.role &&
                       // Validate flag fields
                       request.resource.data.isFlagged is bool &&
                       (request.resource.data.flagNote is string || !request.resource.data.keys().hasAny(['flagNote'])) &&
                       (request.resource.data.flaggedBy is string || !request.resource.data.keys().hasAny(['flaggedBy']));
      
      // **INVITATION FLOW: Allow activating inactive invitations (legacy support)**
      allow update: if request.auth != null &&
                       resource.data.isActive == false &&
                       request.resource.data.isActive == true &&
                       // Prevent changing critical fields during activation
                       request.resource.data.role == resource.data.role &&
                       request.resource.data.organizationID == resource.data.organizationID &&
                       request.resource.data.email == resource.data.email &&
                       request.resource.data.firstName == resource.data.firstName &&
                       request.resource.data.lastName == resource.data.lastName;
      
      // **INVITATION FLOW: Allow deleting temporary invite documents**
      allow delete: if request.auth != null &&
                       userId.matches('invite_.*') &&
                       resource.data.isTemporaryInvite == true &&
                       (
                         // During acceptance process (any authenticated user can delete temp invite they're accepting)
                         true ||
                         // Admins can delete temporary invites (cleanup)
                         (isAdmin(request.auth.uid) &&
                          belongsToSameOrg(request.auth.uid, resource.data.organizationID))
                       );
      
      // **ADMIN USER DELETION: Allow admins to delete users in their organization**
      allow delete: if request.auth != null &&
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent self-deletion
                       request.auth.uid != userId &&
                       // Only delete real user accounts (not temporary invites)
                       (!resource.data.keys().hasAny(['isTemporaryInvite']) || 
                        resource.data.isTemporaryInvite != true);
    }

    // Sessions collection
    match /sessions/{sessionId} {
      // Users can read sessions from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create sessions for their organization
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users assigned to the session can update it
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (isAdminOrManager(request.auth.uid) ||
                        // Check if user is one of the assigned photographers
                        (resource.data.keys().hasAny(['photographers']) && 
                         request.auth.uid in resource.data.photographers.map(['id'])) ||
                        // Legacy support for single photographer format
                        (resource.data.keys().hasAny(['photographer']) && 
                         request.auth.uid == resource.data.photographer.id));
      
      // Admins/Managers can update any session in their organization
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Allow job box assignment updates by any user in the organization
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Only allow updating job box assignment fields
                       request.resource.data.keys().difference(resource.data.keys()).hasOnly(['hasJobBoxAssigned', 'jobBoxRecordId']) &&
                       // Validate field types and values
                       request.resource.data.hasJobBoxAssigned is bool &&
                       (request.resource.data.jobBoxRecordId == null || 
                        request.resource.data.jobBoxRecordId is string) &&
                       // Prevent changing other session data
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // Allow cloud functions to update clock reminder fields
      allow update: if request.auth == null &&
                       // Only allow updating clock reminder tracking fields
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['clockInReminderSent', 'clockInReminderSentAt']) &&
                       // Prevent changing other session data
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // Admins can delete sessions
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Daily Job Reports collection
    match /dailyJobReports/{reportId} {
      // Users can read their own reports by userId
      allow read: if request.auth != null && 
                     resource.data.userId == request.auth.uid;
      
      // Users can read reports from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create reports for their organization
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users can update their own reports
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (resource.data.keys().hasAny(['yourName']) && 
                        resource.data.yourName == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.displayName);
      
      // Admins/Managers can update any report in their organization
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can delete their own reports
      allow delete: if request.auth != null && 
                       resource.data.userId == request.auth.uid &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins can delete any report in their organization
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Districts collection
    match /districts/{districtId} {
      // Validation function for district data
      function isValidDistrict() {
        return request.resource.data.keys().hasAll(['name', 'organizationID']) &&
               request.resource.data.name is string &&
               request.resource.data.name.size() > 0 &&
               request.resource.data.name.size() <= 100 &&
               request.resource.data.organizationID is string;
      }
      
      // Users can read districts from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins/Managers can create districts
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       isValidDistrict() &&
                       request.resource.data.schoolCount == 0;
      
      // Admins/Managers can update districts
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID &&
                       // Validate name if changed
                       (!request.resource.data.keys().hasAny(['name']) || 
                        (request.resource.data.name is string && 
                         request.resource.data.name.size() > 0 && 
                         request.resource.data.name.size() <= 100));
      
      // Admins can delete districts
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Schools collection
    match /schools/{schoolId} {
      // Users can read schools from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins/Managers can create schools
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users can add location photos to schools in their organization
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Only allow updating the locationPhotos field
                       request.resource.data.keys().difference(resource.data.keys()).hasOnly(['locationPhotos']) &&
                       // Ensure locationPhotos is an array
                       request.resource.data.locationPhotos is list;
      
      // Admins/Managers can update schools (including district assignment and yearbook settings)
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // If updating districtId, ensure it's either null or a valid string
                       (!request.resource.data.keys().hasAny(['districtId']) || 
                        request.resource.data.districtId == null || 
                        request.resource.data.districtId is string) &&
                       // Validate yearbook-related fields
                       (!request.resource.data.keys().hasAny(['currentYearbookListId']) || 
                        request.resource.data.currentYearbookListId == null || 
                        request.resource.data.currentYearbookListId is string) &&
                       (!request.resource.data.keys().hasAny(['yearbookEnabled']) || 
                        request.resource.data.yearbookEnabled is bool) &&
                       (!request.resource.data.keys().hasAny(['yearbookStartMonth']) || 
                        (request.resource.data.yearbookStartMonth is number && 
                         request.resource.data.yearbookStartMonth >= 1 && 
                         request.resource.data.yearbookStartMonth <= 12));
      
      // Admins can delete schools (soft delete recommended)
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Sports Jobs collection
    match /sportsJobs/{jobId} {
      // Users can read sports jobs from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create sports jobs for their organization
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users assigned to the job can update it
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (resource.data.keys().hasAny(['photographer']) && 
                        resource.data.photographer == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.displayName);
      
      // Admins/Managers can update any sports job in their organization
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins can delete sports jobs
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Sports Jobs Locks subcollection for entry-level locking
    match /sportsJobs/{jobId}/locks/{lockId} {
      // Allow authenticated users to read/write locks for sports jobs in their organization
      // This enables the entry locking system to prevent simultaneous editing conflicts
      allow read, write: if request.auth != null && 
                           request.auth.uid != null &&
                           // Ensure user belongs to the same organization as the parent sports job
                           belongsToSameOrg(request.auth.uid, get(/databases/$(database)/documents/sportsJobs/$(jobId)).data.organizationID);
    }

    // Player Search Index collection
    match /playerSearchIndex/{indexId} {
      // Users can read search index from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Only allow system/cloud functions to write to search index
      allow write: if false;
    }

    // Job Boxes collection
    match /jobBoxes/{boxId} {
      // Users can read job boxes from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create/update job boxes for their organization
      allow create, update: if request.auth != null && 
                               belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Admins can delete job boxes
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // SD Cards collection
    match /sdCards/{cardId} {
      // Users can read SD cards from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create/update SD cards for their organization
      allow create, update: if request.auth != null && 
                               belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Admins can delete SD cards
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Records collection (general records)
    match /records/{recordId} {
      // Users can read records from their organization (if organizationID exists)
      allow read: if request.auth != null && 
                     (!resource.data.keys().hasAny(['organizationID']) || 
                      belongsToSameOrg(request.auth.uid, resource.data.organizationID));
      
      // Users can create records
      allow create: if request.auth != null;
      
      // Users can update their own records or admins can update any
      allow update: if request.auth != null && 
                       (resource.data.keys().hasAny(['createdBy']) && 
                        request.auth.uid == resource.data.createdBy ||
                        isAdmin(request.auth.uid));
      
      // Admins can delete records
      allow delete: if request.auth != null && isAdmin(request.auth.uid);
    }

    // Report Templates collection (for custom daily report templates)
    match /reportTemplates/{templateId} {
      // Users can read templates from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins/Managers can create templates
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Ensure required fields are present
                       request.resource.data.keys().hasAll(['name', 'organizationID', 'fields', 'isActive']) &&
                       // Validate data types
                       request.resource.data.name is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.fields is list &&
                       request.resource.data.isActive is bool &&
                       // Validate shootType if present
                       (!request.resource.data.keys().hasAny(['shootType']) || request.resource.data.shootType is string) &&
                       // Validate version if present
                       (!request.resource.data.keys().hasAny(['version']) || request.resource.data.version is int) &&
                       // Validate isDefault if present
                       (!request.resource.data.keys().hasAny(['isDefault']) || request.resource.data.isDefault is bool);
      
      // Admins/Managers can update templates
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID &&
                       // Validate required fields still present
                       request.resource.data.keys().hasAll(['name', 'organizationID', 'fields', 'isActive']) &&
                       // Validate data types
                       request.resource.data.name is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.fields is list &&
                       request.resource.data.isActive is bool;
      
      // Admins can delete templates
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Time Entries collection (for clock in/out tracking)
    match /timeEntries/{entryId} {
      // Users can read time entries from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create their own time entries
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.userId &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['userId', 'organizationID', 'clockInTime', 'date', 'status']) &&
                       // Validate data types
                       request.resource.data.userId is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.clockInTime is timestamp &&
                       request.resource.data.date is string &&
                       request.resource.data.status in ['clocked-in', 'clocked-out'] &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['sessionId']) || request.resource.data.sessionId is string) &&
                       (!request.resource.data.keys().hasAny(['clockOutTime']) || request.resource.data.clockOutTime is timestamp) &&
                       (!request.resource.data.keys().hasAny(['notes']) || request.resource.data.notes is string);
      
      // Users can update their own time entries (for clock out and editing completed entries)
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.userId &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing core identity fields
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.organizationID == resource.data.organizationID &&
                       (
                         // Allow clock out operations (clockInTime and date unchanged)
                         (request.resource.data.clockInTime == resource.data.clockInTime &&
                          request.resource.data.date == resource.data.date) ||
                         // Allow editing completed entries (can change times and date, but must be completed)
                         (resource.data.status == 'clocked-out' &&
                          request.resource.data.status == 'clocked-out' &&
                          // Validate reasonable working hours (max 16 hours)
                          request.resource.data.clockOutTime > request.resource.data.clockInTime &&
                          (request.resource.data.clockOutTime.toMillis() - request.resource.data.clockInTime.toMillis()) <= 57600000 && // 16 hours in milliseconds
                          // Validate data types for edited fields
                          request.resource.data.clockInTime is timestamp &&
                          request.resource.data.clockOutTime is timestamp &&
                          request.resource.data.date is string &&
                          (!request.resource.data.keys().hasAny(['notes']) || request.resource.data.notes is string) &&
                          (!request.resource.data.keys().hasAny(['sessionId']) || request.resource.data.sessionId is string))
                       );
      
      // Admins/Managers can create and update any time entries in their organization
      allow create, update: if request.auth != null && 
                               isAdminOrManager(request.auth.uid) &&
                               belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users can delete their own time entries, admins can delete any
      allow delete: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (
                         // Users can delete their own entries
                         request.auth.uid == resource.data.userId ||
                         // Admins can delete any entry in their organization
                         isAdmin(request.auth.uid)
                       );
    }

    // Time Off Requests collection
    match /timeOffRequests/{requestId} {
      // Users can read time off requests from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create their own time off requests
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.photographerId &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationID', 'photographerId', 'photographerName', 'startDate', 'endDate', 'reason', 'status']) &&
                       // Validate data types
                       request.resource.data.organizationID is string &&
                       request.resource.data.photographerId is string &&
                       request.resource.data.photographerName is string &&
                       request.resource.data.startDate is timestamp &&
                       request.resource.data.endDate is timestamp &&
                       request.resource.data.reason is string &&
                       request.resource.data.status == 'pending' &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['notes']) || request.resource.data.notes is string) &&
                       // Validate priority fields
                       (!request.resource.data.keys().hasAny(['priority']) || request.resource.data.priority in ['normal', 'high']) &&
                       (!request.resource.data.keys().hasAny(['priorityReason']) || request.resource.data.priorityReason is string) &&
                       (!request.resource.data.keys().hasAny(['bypassedBlockedDates']) || request.resource.data.bypassedBlockedDates is bool) &&
                       (!request.resource.data.keys().hasAny(['blockedDatesAcknowledged']) || request.resource.data.blockedDatesAcknowledged is bool) &&
                       // Validate PTO fields
                       (!request.resource.data.keys().hasAny(['isPaidTimeOff']) || request.resource.data.isPaidTimeOff is bool) &&
                       (!request.resource.data.keys().hasAny(['ptoHoursRequested']) || 
                        (request.resource.data.ptoHoursRequested is number && 
                         request.resource.data.ptoHoursRequested >= 0 && 
                         request.resource.data.ptoHoursRequested <= 8)) &&
                       // If using PTO, hours must be specified
                       ((!request.resource.data.keys().hasAny(['isPaidTimeOff']) || !request.resource.data.isPaidTimeOff) || 
                        (request.resource.data.keys().hasAny(['ptoHoursRequested']) && request.resource.data.ptoHoursRequested > 0)) &&
                       // If high priority, priorityReason must be provided
                       ((!request.resource.data.keys().hasAny(['priority']) || request.resource.data.priority == 'normal') || 
                        (request.resource.data.priority == 'high' && request.resource.data.keys().hasAny(['priorityReason']) && request.resource.data.priorityReason is string));
      
      // Users can update their own pending requests (to cancel or edit)
      // Admins/Managers can update any request (to approve/deny)
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (
                         // Users can update their own pending requests
                         (request.auth.uid == resource.data.photographerId && 
                          resource.data.status == 'pending' &&
                          // Prevent changing core fields
                          request.resource.data.photographerId == resource.data.photographerId &&
                          request.resource.data.organizationID == resource.data.organizationID) ||
                         // Admins/Managers can approve/deny/mark as under review
                         (isAdminOrManager(request.auth.uid) &&
                          // Validate approval fields
                          ((request.resource.data.status == 'approved' && 
                           request.resource.data.keys().hasAll(['approvedBy', 'approverName', 'approvedAt']) &&
                           request.resource.data.approvedBy is string &&
                           request.resource.data.approverName is string &&
                           request.resource.data.approvedAt is timestamp) ||
                          // Validate denial fields
                          (request.resource.data.status == 'denied' && 
                           request.resource.data.keys().hasAll(['deniedBy', 'denierName', 'deniedAt', 'denialReason']) &&
                           request.resource.data.deniedBy is string &&
                           request.resource.data.denierName is string &&
                           request.resource.data.deniedAt is timestamp &&
                           request.resource.data.denialReason is string) ||
                          // Validate under review fields
                          (request.resource.data.status == 'under_review' && 
                           request.resource.data.keys().hasAll(['reviewedBy', 'reviewerName', 'reviewedAt']) &&
                           request.resource.data.reviewedBy is string &&
                           request.resource.data.reviewerName is string &&
                           request.resource.data.reviewedAt is timestamp) ||
                          // Allow cancelled status
                          request.resource.data.status == 'cancelled' ||
                          // Allow partially approved status (day-by-day approval)
                          (request.resource.data.status == 'partially_approved' &&
                           request.resource.data.keys().hasAll(['lastReviewedBy', 'lastReviewerName', 'lastReviewedAt']) &&
                           request.resource.data.lastReviewedBy is string &&
                           request.resource.data.lastReviewerName is string &&
                           request.resource.data.lastReviewedAt is timestamp &&
                           (!request.resource.data.keys().hasAny(['dayStatuses']) || request.resource.data.dayStatuses is map) &&
                           (!request.resource.data.keys().hasAny(['hasPartialApproval']) || request.resource.data.hasPartialApproval is bool))))
                       );
      
      // Only admins can delete time off requests
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Workflow Templates collection
    match /workflowTemplates/{templateId} {
      // Users can read workflow templates from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins/Managers can create workflow templates
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['name', 'organizationID', 'steps', 'isActive']) &&
                       // Validate data types
                       request.resource.data.name is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.steps is list &&
                       request.resource.data.isActive is bool &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['description']) || request.resource.data.description is string) &&
                       (!request.resource.data.keys().hasAny(['sessionTypes']) || request.resource.data.sessionTypes is list) &&
                       (!request.resource.data.keys().hasAny(['trackingTypes']) || request.resource.data.trackingTypes is list) &&
                       (!request.resource.data.keys().hasAny(['estimatedDays']) || request.resource.data.estimatedDays is number) &&
                       (!request.resource.data.keys().hasAny(['isDefault']) || request.resource.data.isDefault is bool) &&
                       (!request.resource.data.keys().hasAny(['version']) || request.resource.data.version is number);
      
      // Admins/Managers can update workflow templates
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // Admins can delete workflow templates (soft delete - set isActive: false)
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Workflows collection (workflow instances)
    match /workflows/{workflowId} {
      // Users can read workflows from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // System can create workflows (auto-created when sessions complete)
      // Admins/Managers can also manually create workflows
      // Supports both session-based workflows and tracking workflows
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Common required fields
                       request.resource.data.keys().hasAll(['organizationID', 'templateId', 'stepProgress']) &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.templateId is string &&
                       request.resource.data.stepProgress is map &&
                       (
                         // Session-based workflow validation
                         (request.resource.data.keys().hasAll(['sessionId']) &&
                          request.resource.data.sessionId is string &&
                          (!request.resource.data.keys().hasAny(['workflowType']) || 
                           request.resource.data.workflowType != 'tracking')) ||
                         // Tracking workflow validation
                         (request.resource.data.keys().hasAll(['schoolId', 'trackingTemplateId', 'academicYear', 'workflowType']) &&
                          request.resource.data.schoolId is string &&
                          request.resource.data.trackingTemplateId is string &&
                          request.resource.data.academicYear is string &&
                          request.resource.data.workflowType == 'tracking' &&
                          (!request.resource.data.keys().hasAny(['trackingStartDate']) || request.resource.data.trackingStartDate is string) &&
                          (!request.resource.data.keys().hasAny(['trackingEndDate']) || request.resource.data.trackingEndDate is string) &&
                          (!request.resource.data.keys().hasAny(['schoolName']) || request.resource.data.schoolName is string))
                       ) &&
                       // Validate optional fields (common to both types)
                       (!request.resource.data.keys().hasAny(['status']) || request.resource.data.status in ['active', 'completed', 'on_hold', 'cancelled', 'deleted']) &&
                       (!request.resource.data.keys().hasAny(['templateName']) || request.resource.data.templateName is string) &&
                       (!request.resource.data.keys().hasAny(['templateVersion']) || request.resource.data.templateVersion is number) &&
                       (!request.resource.data.keys().hasAny(['currentStep']) || request.resource.data.currentStep is string);
      
      // Granular step-level permissions for workflow updates
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing core identity fields
                       request.resource.data.organizationID == resource.data.organizationID &&
                       request.resource.data.templateId == resource.data.templateId &&
                       (
                         // Session-based workflow: prevent changing sessionId
                         (resource.data.keys().hasAny(['sessionId']) &&
                          request.resource.data.sessionId == resource.data.sessionId) ||
                         // Tracking workflow: prevent changing tracking identity fields
                         (resource.data.workflowType == 'tracking' &&
                          request.resource.data.schoolId == resource.data.schoolId &&
                          request.resource.data.trackingTemplateId == resource.data.trackingTemplateId &&
                          request.resource.data.academicYear == resource.data.academicYear &&
                          request.resource.data.workflowType == resource.data.workflowType)
                       ) &&
                       (
                         // Admins/Managers can update any workflow
                         isAdminOrManager(request.auth.uid) ||
                         // Regular users can update workflows (simplified for now)
                         // TODO: Add granular step-level permissions in future iteration
                         true
                       );
      
      // Admins can delete workflows
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Blocked Dates collection (for blocking time off requests)
    match /blockedDates/{blockedDateId} {
      // Users in the same organization can read blocked dates
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Only admins and managers can create blocked dates
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationID', 'startDate', 'endDate', 'reason', 'createdBy', 'createdAt', 'allowHighPriority']) &&
                       // Validate data types
                       request.resource.data.organizationID is string &&
                       request.resource.data.startDate is timestamp &&
                       request.resource.data.endDate is timestamp &&
                       request.resource.data.reason is string &&
                       request.resource.data.createdBy is string &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.allowHighPriority is bool &&
                       // Ensure end date is after start date
                       request.resource.data.endDate > request.resource.data.startDate;
      
      // Only admins and managers can update blocked dates
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID &&
                       // Validate data types if fields are being updated
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['startDate']) || request.resource.data.startDate is timestamp) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['endDate']) || request.resource.data.endDate is timestamp) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['reason']) || request.resource.data.reason is string) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['allowHighPriority']) || request.resource.data.allowHighPriority is bool) &&
                       // Ensure end date is after start date
                       request.resource.data.endDate > request.resource.data.startDate;
      
      // Only admins and managers can delete blocked dates
      allow delete: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // ============================================================================
    // PRODUCTION-READY PTO BALANCES COLLECTION
    // ============================================================================
    match /ptoBalances/{balanceId} {
      // PRODUCTION PTO READ RULES - Handles both existing and non-existent documents
      allow read: if request.auth != null && 
                     (
                       // Case 1: Document exists - validate user belongs to same organization
                       (resource != null && 
                        resource.data.keys().hasAny(['organizationID']) &&
                        belongsToSameOrg(request.auth.uid, resource.data.organizationID)) ||
                       
                       // Case 2: Document doesn't exist - validate predictable ID format and ownership
                       (resource == null && 
                        isValidPTODocumentAccess(balanceId, request.auth.uid)) ||
                       
                       // Case 3: Admin access - admins can read any PTO balance in their organization
                       (resource != null && 
                        resource.data.keys().hasAny(['organizationID']) &&
                        isAdmin(request.auth.uid) && 
                        belongsToSameOrg(request.auth.uid, resource.data.organizationID))
                     );
      
      // PRODUCTION PTO CREATE RULES - Auto-creation of balance documents
      allow create: if (request.auth != null && 
                       // Validate document ID follows predictable format
                       isValidPTODocumentAccess(balanceId, request.auth.uid) &&
                       // Validate user belongs to organization being created
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID)) ||
                       // Allow Cloud Functions to create PTO balance documents
                       (request.auth == null) &&
                       // Validate required fields are present
                       request.resource.data.keys().hasAll(['userId', 'organizationID']) &&
                       // Validate core field types
                       request.resource.data.userId is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.userId == request.auth.uid &&
                       // Validate optional numeric fields (must be numbers if present)
                       (!request.resource.data.keys().hasAny(['currentBalance']) || 
                        (request.resource.data.currentBalance is number && request.resource.data.currentBalance >= 0)) &&
                       (!request.resource.data.keys().hasAny(['pendingBalance']) || 
                        (request.resource.data.pendingBalance is number && request.resource.data.pendingBalance >= 0)) &&
                       (!request.resource.data.keys().hasAny(['usedThisYear']) || 
                        (request.resource.data.usedThisYear is number && request.resource.data.usedThisYear >= 0)) &&
                       (!request.resource.data.keys().hasAny(['earnedThisYear']) || 
                        (request.resource.data.earnedThisYear is number && request.resource.data.earnedThisYear >= 0)) &&
                       (!request.resource.data.keys().hasAny(['bankingBalance']) || 
                        (request.resource.data.bankingBalance is number && request.resource.data.bankingBalance >= 0)) &&
                       // Validate optional timestamp fields
                       (!request.resource.data.keys().hasAny(['lastAccrualDate']) || 
                        request.resource.data.lastAccrualDate is timestamp || request.resource.data.lastAccrualDate == null) &&
                       (!request.resource.data.keys().hasAny(['lastResetDate']) || 
                        request.resource.data.lastResetDate is timestamp || request.resource.data.lastResetDate == null) &&
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt is timestamp) &&
                       (!request.resource.data.keys().hasAny(['updatedAt']) || 
                        request.resource.data.updatedAt is timestamp);
      
      // PRODUCTION PTO UPDATE RULES - Balance updates and accrual
      allow update: if (request.auth != null && 
                       // Validate user belongs to same organization
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing core identity fields
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.organizationID == resource.data.organizationID &&
                       (
                         // Case 1: User updating their own balance (for accrual, reservations, usage)
                         (resource.data.userId == request.auth.uid &&
                          // Validate numeric fields are valid if being updated
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['totalBalance']) || 
                           (request.resource.data.totalBalance is number && request.resource.data.totalBalance >= 0)) &&
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['pendingBalance']) || 
                           (request.resource.data.pendingBalance is number && request.resource.data.pendingBalance >= 0)) &&
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['usedThisYear']) || 
                           (request.resource.data.usedThisYear is number && request.resource.data.usedThisYear >= 0)) &&
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['bankingBalance']) || 
                           (request.resource.data.bankingBalance is number && request.resource.data.bankingBalance >= 0))) ||
                         
                         // Case 2: Admin making manual adjustments
                         (isAdmin(request.auth.uid) &&
                          belongsToSameOrg(request.auth.uid, resource.data.organizationID))
                       )) ||
                       // Case 3: Cloud Functions automatic processing
                       (request.auth == null &&
                        // Validate core identity fields don't change
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.organizationID == resource.data.organizationID);
      
      // PRODUCTION PTO DELETE RULES - Only admins can delete (for cleanup)
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // ============================================================================
    // PRODUCTION-READY PTO ADJUSTMENTS COLLECTION (Audit Trail)
    // ============================================================================
    match /ptoAdjustments/{adjustmentId} {
      // Only admins and managers can read adjustment history
      allow read: if request.auth != null && 
                     isAdminOrManager(request.auth.uid) &&
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Only admins can create manual PTO adjustments
      allow create: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields for audit trail
                       request.resource.data.keys().hasAll(['userId', 'organizationID', 'adjustment', 'reason', 'adminId', 'previousBalance', 'newBalance']) &&
                       // Validate field types
                       request.resource.data.userId is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.adjustment is number &&
                       request.resource.data.reason is string &&
                       request.resource.data.adminId == request.auth.uid &&
                       request.resource.data.previousBalance is number &&
                       request.resource.data.newBalance is number &&
                       request.resource.data.previousBalance >= 0 &&
                       request.resource.data.newBalance >= 0 &&
                       // Validate timestamps
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt is timestamp);
      
      // No updates or deletes allowed (immutable audit trail)
      allow update, delete: if false;
    }

    // ============================================================================
    // CHAT SYSTEM - CONVERSATIONS AND MESSAGES
    // ============================================================================
    
    // Conversations collection
    match /conversations/{conversationId} {
      // Users can read conversations they participate in
      allow read: if request.auth != null && 
                     request.auth.uid in resource.data.participants;
      
      // Users can create conversations they participate in
      allow create: if request.auth != null && 
                       // User must be in participants list
                       request.auth.uid in request.resource.data.participants &&
                       // Validate required fields (only essential ones)
                       request.resource.data.keys().hasAll(['participants', 'type']) &&
                       // Validate data types
                       request.resource.data.participants is list &&
                       request.resource.data.type in ['direct', 'group'] &&
                       // Validate participants list includes current user
                       request.resource.data.participants.size() >= 2 &&
                       request.resource.data.participants.size() <= 50 &&
                       request.auth.uid in request.resource.data.participants &&
                       // Validate optional timestamp fields (allow server timestamps)
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == request.time)) &&
                       (!request.resource.data.keys().hasAny(['lastActivity']) || 
                        (request.resource.data.lastActivity is timestamp || request.resource.data.lastActivity == request.time)) &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['name']) || 
                        (request.resource.data.name is string || request.resource.data.name == null)) &&
                       (!request.resource.data.keys().hasAny(['defaultName']) || request.resource.data.defaultName is string) &&
                       (!request.resource.data.keys().hasAny(['lastMessage']) || 
                        (request.resource.data.lastMessage is map || request.resource.data.lastMessage == null)) &&
                       (!request.resource.data.keys().hasAny(['unreadCounts']) || request.resource.data.unreadCounts is map);
      
      // Participants can update conversation metadata (last message, activity, unread counts)
      allow update: if request.auth != null && 
                       request.auth.uid in resource.data.participants &&
                       // Ensure user remains a participant (can't remove themselves)
                       request.auth.uid in request.resource.data.participants &&
                       // Prevent changing type and creation date
                       request.resource.data.type == resource.data.type &&
                       (!resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt == resource.data.createdAt) &&
                       // Allow updating participants array (for adding/removing users)
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['participants']) || 
                        (request.resource.data.participants is list &&
                         request.resource.data.participants.size() >= 2 &&
                         request.resource.data.participants.size() <= 50)) &&
                       // Allow updating pinnedBy array (for pinning conversations)
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['pinnedBy']) || 
                        (request.resource.data.pinnedBy is list || !request.resource.data.keys().hasAny(['pinnedBy']))) &&
                       // Allow updating activity and message-related fields (with server timestamps)
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['lastActivity']) || 
                        (request.resource.data.lastActivity is timestamp || request.resource.data.lastActivity == request.time)) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['lastMessage']) || 
                        (request.resource.data.lastMessage is map || request.resource.data.lastMessage == null)) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['unreadCounts']) || 
                        request.resource.data.unreadCounts is map) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['name']) || 
                        (request.resource.data.name is string || request.resource.data.name == null));
      
      // Only admins can delete conversations (for cleanup)
      allow delete: if request.auth != null && isAdmin(request.auth.uid);
    }
    
    // Messages collection (using path: messages/{conversationId}/messages/{messageId})
    match /messages/{conversationId}/messages/{messageId} {
      // Users can read messages from conversations they participate in
      allow read: if request.auth != null && 
                     exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                     request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
      
      // Users can send messages to conversations they participate in
      allow create: if request.auth != null && 
                       exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                       request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                       (
                         // Regular messages - user must be the sender
                         (request.resource.data.type != 'system' &&
                          request.auth.uid == request.resource.data.senderId &&
                          // Validate required fields for regular messages
                          request.resource.data.keys().hasAll(['senderId', 'text', 'type']) &&
                          // Validate data types
                          request.resource.data.senderId is string &&
                          request.resource.data.text is string &&
                          request.resource.data.type is string &&
                          // Validate text length
                          request.resource.data.text.size() <= 2000) ||
                         
                         // System messages - for participant changes
                         (request.resource.data.type == 'system' &&
                          request.resource.data.keys().hasAll(['type', 'systemAction']) &&
                          request.resource.data.systemAction in ['participants_added', 'participant_removed', 'participant_left'] &&
                          // Validate system message fields based on action
                          ((request.resource.data.systemAction == 'participants_added' &&
                            request.resource.data.keys().hasAny(['addedBy', 'addedByName', 'addedParticipants'])) ||
                           (request.resource.data.systemAction == 'participant_removed' &&
                            request.resource.data.keys().hasAny(['removedBy', 'removedByName', 'removedParticipant'])) ||
                           (request.resource.data.systemAction == 'participant_left' &&
                            request.resource.data.keys().hasAny(['leftUserId', 'leftUserName']))))
                       ) &&
                       // Validate optional timestamp fields (allow server timestamps)
                       (!request.resource.data.keys().hasAny(['timestamp']) || 
                        (request.resource.data.timestamp is timestamp || request.resource.data.timestamp == request.time)) &&
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == request.time)) &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['fileUrl']) || 
                        (request.resource.data.fileUrl is string || request.resource.data.fileUrl == null)) &&
                       (!request.resource.data.keys().hasAny(['senderName']) || 
                        request.resource.data.senderName is string);
      
      // Message senders can update their own messages (for editing)
      allow update: if request.auth != null && 
                       exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                       request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                       request.auth.uid == resource.data.senderId &&
                       // Prevent changing core fields
                       request.resource.data.senderId == resource.data.senderId &&
                       (!resource.data.keys().hasAny(['timestamp']) || 
                        request.resource.data.timestamp == resource.data.timestamp) &&
                       (!resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt == resource.data.createdAt) &&
                       // Only allow editing text and type
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['text']) || 
                        (request.resource.data.text is string && request.resource.data.text.size() <= 2000)) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['type']) || 
                        request.resource.data.type is string);
      
      // Only admins can delete messages (for moderation)
      allow delete: if request.auth != null && isAdmin(request.auth.uid);
    }

    // ============================================================================
    // PROOFING SYSTEM - GALLERIES, PROOFS, AND ACTIVITY
    // ============================================================================
    
    // Proof Galleries collection
    match /proofGalleries/{galleryId} {
      // PUBLIC ACCESS: Anyone with the gallery ID can read (for public proofing links)
      allow read: if true;
      
      // Only authenticated users from the organization can create galleries
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationId) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationId', 'schoolId', 'schoolName', 'name', 'status']) &&
                       // Validate data types
                       request.resource.data.organizationId is string &&
                       request.resource.data.schoolId is string &&
                       request.resource.data.schoolName is string &&
                       request.resource.data.name is string &&
                       request.resource.data.status == 'pending' &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['password']) || 
                        request.resource.data.password is string || request.resource.data.password == null) &&
                       (!request.resource.data.keys().hasAny(['deadline']) || 
                        request.resource.data.deadline is timestamp || request.resource.data.deadline == null) &&
                       // Validate numeric fields
                       request.resource.data.totalImages == 0 &&
                       request.resource.data.approvedCount == 0 &&
                       request.resource.data.deniedCount == 0;
      
      // Only organization members can update galleries
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId) &&
                       // Prevent changing organization
                       request.resource.data.organizationId == resource.data.organizationId;
      
      // PUBLIC ACCESS: Allow updates from public users (for status updates)
      allow update: if true &&
                       // Only allow updating specific fields from public
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['status', 'approvedCount', 'deniedCount', 'updatedAt']) &&
                       // Validate status transitions
                       request.resource.data.status in ['pending', 'partial', 'approved', 'has_denials'];
      
      // Only admins can delete galleries
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId);
    }
    
    // Proofs collection (individual proof images)
    match /proofs/{proofId} {
      // PUBLIC ACCESS: Anyone can read proofs (filtered by gallery ID in app)
      allow read: if true;
      
      // Only authenticated users from the organization can create proofs
      allow create: if request.auth != null && 
                       // Verify the gallery exists and user has access
                       exists(/databases/$(database)/documents/proofGalleries/$(request.resource.data.galleryId)) &&
                       belongsToSameOrg(request.auth.uid, 
                         get(/databases/$(database)/documents/proofGalleries/$(request.resource.data.galleryId)).data.organizationId) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['galleryId', 'filename', 'imageUrl', 'order', 'status']) &&
                       // Validate data types
                       request.resource.data.galleryId is string &&
                       request.resource.data.filename is string &&
                       request.resource.data.imageUrl is string &&
                       request.resource.data.order is int &&
                       request.resource.data.status == 'pending' &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['thumbnailUrl']) || 
                        request.resource.data.thumbnailUrl is string) &&
                       (!request.resource.data.keys().hasAny(['denialNotes']) || 
                        request.resource.data.denialNotes == null);
      
      // Combined update rule: Organization members for versioning OR public users for review
      allow update: if 
        // Case 1: Organization members updating versioning fields
        (request.auth != null &&
         exists(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)) &&
         belongsToSameOrg(request.auth.uid, 
           get(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)).data.organizationId) &&
         // Prevent changing core fields
         request.resource.data.galleryId == resource.data.galleryId &&
         request.resource.data.filename == resource.data.filename &&
         // Allow updating versioning fields
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['imageUrl', 'thumbnailUrl', 'status', 'denialNotes', 
                    'currentVersion', 'versionCount', 'hasVersions', 
                    'lastRevisionId', 'updatedAt']) &&
         // Validate version fields
         (!request.resource.data.keys().hasAny(['currentVersion']) || 
          request.resource.data.currentVersion is int) &&
         (!request.resource.data.keys().hasAny(['versionCount']) || 
          request.resource.data.versionCount is int) &&
         (!request.resource.data.keys().hasAny(['hasVersions']) || 
          request.resource.data.hasVersions is bool)) ||
        // Case 2: Public users updating status only
        (// Only allow updating specific fields
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['status', 'denialNotes', 'reviewedAt', 'reviewedBy', 'updatedAt']) &&
         // Validate status
         request.resource.data.status in ['pending', 'approved', 'denied'] &&
         // If denied, must have notes
         (request.resource.data.status != 'denied' || 
          (request.resource.data.denialNotes is string && 
           request.resource.data.denialNotes.size() > 0)) &&
         // Validate reviewer email if provided
         (!request.resource.data.keys().hasAny(['reviewedBy']) || 
          request.resource.data.reviewedBy is string));
      
      // Only admins from the organization can delete proofs
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       exists(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)) &&
                       belongsToSameOrg(request.auth.uid, 
                         get(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)).data.organizationId);
    }
    
    // Proof Activity collection (tracking views and actions)
    match /proofActivity/{activityId} {
      // Only organization members can read activity logs
      allow read: if request.auth != null && 
                     exists(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)) &&
                     belongsToSameOrg(request.auth.uid, 
                       get(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)).data.organizationId);
      
      // PUBLIC ACCESS: Anyone can create activity logs
      allow create: if true &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['galleryId', 'action', 'userEmail']) &&
                       // Validate data types
                       request.resource.data.galleryId is string &&
                       request.resource.data.action in ['viewed', 'approved', 'denied', 'batch_replaced'] &&
                       request.resource.data.userEmail is string &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['proofId']) || 
                        request.resource.data.proofId is string || request.resource.data.proofId == null) &&
                       (!request.resource.data.keys().hasAny(['count']) || 
                        request.resource.data.count is number);
      
      // No updates allowed (activity logs are immutable)
      allow update: if false;
      
      // Only admins can delete activity logs
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       exists(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)) &&
                       belongsToSameOrg(request.auth.uid, 
                         get(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)).data.organizationId);
    }
    
    // Proof Revisions collection (version history for proofs)
    match /proofRevisions/{revisionId} {
      // PUBLIC ACCESS: Allow reading revisions for gallery review OR organization members can read
      allow read: if true || 
                     (request.auth != null && 
                      exists(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)) &&
                      belongsToSameOrg(request.auth.uid, 
                        get(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)).data.organizationId));
      
      // Only authenticated users from the organization can create revisions
      allow create: if request.auth != null && 
                       exists(/databases/$(database)/documents/proofGalleries/$(request.resource.data.galleryId)) &&
                       belongsToSameOrg(request.auth.uid, 
                         get(/databases/$(database)/documents/proofGalleries/$(request.resource.data.galleryId)).data.organizationId) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['proofId', 'galleryId', 'originalImageUrl', 'newImageUrl', 'versionNumber']) &&
                       // Validate data types
                       request.resource.data.proofId is string &&
                       request.resource.data.galleryId is string &&
                       request.resource.data.originalImageUrl is string &&
                       request.resource.data.newImageUrl is string &&
                       request.resource.data.versionNumber is int &&
                       request.resource.data.versionNumber > 0 &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['denialNotes']) || 
                        request.resource.data.denialNotes is string || request.resource.data.denialNotes == null) &&
                       (!request.resource.data.keys().hasAny(['studioNotes']) || 
                        request.resource.data.studioNotes is string || request.resource.data.studioNotes == null) &&
                       (!request.resource.data.keys().hasAny(['replacedBy']) || 
                        request.resource.data.replacedBy is string) &&
                       (!request.resource.data.keys().hasAny(['previousVersion']) || 
                        request.resource.data.previousVersion is int) &&
                       (!request.resource.data.keys().hasAny(['isLatest']) || 
                        request.resource.data.isLatest is bool) &&
                       // Allow timestamp fields
                       (!request.resource.data.keys().hasAny(['replacedAt']) || 
                        request.resource.data.replacedAt is timestamp);
      
      // Only allow updating isLatest flag by organization members
      allow update: if request.auth != null && 
                       exists(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)) &&
                       belongsToSameOrg(request.auth.uid, 
                         get(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)).data.organizationId) &&
                       // Only allow updating isLatest field
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isLatest']) &&
                       request.resource.data.isLatest is bool;
      
      // Only admins can delete revisions
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       exists(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)) &&
                       belongsToSameOrg(request.auth.uid, 
                         get(/databases/$(database)/documents/proofGalleries/$(resource.data.galleryId)).data.organizationId);
    }

    // ============================================================================
    // YEARBOOK SHOOT LISTS COLLECTION
    // ============================================================================
    match /yearbookShootLists/{listId} {
      // Users can read yearbook lists from schools in their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationId);
      
      // Admins and photographers can create yearbook lists
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationId) &&
                       (isAdmin(request.auth.uid) || getUserRole(request.auth.uid) == 'photographer') &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationId', 'schoolId', 'schoolName', 'schoolYear']) &&
                       // Validate data types
                       request.resource.data.organizationId is string &&
                       request.resource.data.schoolId is string &&
                       request.resource.data.schoolName is string &&
                       request.resource.data.schoolYear is string &&
                       // Validate year format (e.g., "2024-2025")
                       request.resource.data.schoolYear.matches('^[0-9]{4}-[0-9]{4}$') &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['isActive']) || request.resource.data.isActive is bool) &&
                       (!request.resource.data.keys().hasAny(['copiedFromId']) || 
                        request.resource.data.copiedFromId is string || request.resource.data.copiedFromId == null) &&
                       (!request.resource.data.keys().hasAny(['completedCount']) || 
                        (request.resource.data.completedCount is number && request.resource.data.completedCount >= 0)) &&
                       (!request.resource.data.keys().hasAny(['totalCount']) || 
                        (request.resource.data.totalCount is number && request.resource.data.totalCount >= 0)) &&
                       (!request.resource.data.keys().hasAny(['items']) || request.resource.data.items is list) &&
                       (!request.resource.data.keys().hasAny(['startDate']) || request.resource.data.startDate is timestamp) &&
                       (!request.resource.data.keys().hasAny(['endDate']) || request.resource.data.endDate is timestamp);
      
      // Admins and photographers can update yearbook lists
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId) &&
                       (isAdmin(request.auth.uid) || getUserRole(request.auth.uid) == 'photographer') &&
                       // Prevent changing core identity fields
                       request.resource.data.organizationId == resource.data.organizationId &&
                       request.resource.data.schoolId == resource.data.schoolId &&
                       request.resource.data.schoolYear == resource.data.schoolYear &&
                       // Validate updated fields
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['items']) || 
                        request.resource.data.items is list) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['completedCount']) || 
                        (request.resource.data.completedCount is number && request.resource.data.completedCount >= 0)) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['totalCount']) || 
                        (request.resource.data.totalCount is number && request.resource.data.totalCount >= 0));
      
      // Only admins can delete yearbook lists
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId);
    }

    // ============================================================================
    // YEARBOOK TEMPLATES COLLECTION
    // ============================================================================
    match /yearbookTemplates/{templateId} {
      // Users can read yearbook templates from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationId);
      
      // Admins can create yearbook templates
      allow create: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationId) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationId', 'name', 'categories']) &&
                       // Validate data types
                       request.resource.data.organizationId is string &&
                       request.resource.data.name is string &&
                       request.resource.data.categories is list &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['description']) || request.resource.data.description is string) &&
                       (!request.resource.data.keys().hasAny(['schoolType']) || 
                        request.resource.data.schoolType in ['elementary', 'middle', 'high', 'k8', 'k12', 'other']) &&
                       (!request.resource.data.keys().hasAny(['isDefault']) || request.resource.data.isDefault is bool) &&
                       (!request.resource.data.keys().hasAny(['isActive']) || request.resource.data.isActive is bool);
      
      // Admins can update yearbook templates
      allow update: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId) &&
                       // Prevent changing organizationId
                       request.resource.data.organizationId == resource.data.organizationId;
      
      // Only admins can delete yearbook templates
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId);
    }

    // ============================================================================
    // CLASS GROUP JOBS COLLECTION
    // ============================================================================
    match /classGroupJobs/{jobId} {
      // Users can read class group jobs from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationId);
      
      // Users can create class group jobs for their organization
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationId) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationId', 'sessionId', 'sessionDate', 'schoolId', 'schoolName', 'classGroups']) &&
                       // Validate data types
                       request.resource.data.organizationId is string &&
                       request.resource.data.sessionId is string &&
                       request.resource.data.sessionDate is timestamp &&
                       request.resource.data.schoolId is string &&
                       request.resource.data.schoolName is string &&
                       request.resource.data.classGroups is list &&
                       // Validate creator fields
                       request.resource.data.createdBy == request.auth.uid &&
                       request.resource.data.lastModifiedBy == request.auth.uid &&
                       // Validate timestamps
                       (!request.resource.data.keys().hasAny(['createdAt']) || request.resource.data.createdAt is timestamp) &&
                       (!request.resource.data.keys().hasAny(['updatedAt']) || request.resource.data.updatedAt is timestamp);
      
      // Users can update class group jobs in their organization
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId) &&
                       // Prevent changing core identity fields
                       request.resource.data.organizationId == resource.data.organizationId &&
                       request.resource.data.sessionId == resource.data.sessionId &&
                       request.resource.data.schoolId == resource.data.schoolId &&
                       // Update lastModifiedBy
                       request.resource.data.lastModifiedBy == request.auth.uid &&
                       // Validate classGroups array
                       request.resource.data.classGroups is list &&
                       // Validate timestamps
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['updatedAt']) || 
                        request.resource.data.updatedAt is timestamp);
      
      // Admins can delete class group jobs
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationId);
    }

    // ============================================================================
    // NOTIFICATION SYSTEM - AUDIT AND LOGGING
    // ============================================================================
    
    // Audit Logs collection (for flag notifications and other audit trails)
    match /auditLogs/{document} {
      // Only cloud functions can write audit logs
      allow write: if false;
      
      // Users can read logs about themselves or that they created
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.targetUserId || 
         request.auth.uid == resource.data.performedBy ||
         isAdminOrManager(request.auth.uid));
    }
    
    // Notification Logs collection (for notification delivery tracking)
    match /notificationLogs/{document} {
      // Only cloud functions can write notification logs
      allow write: if false;
      
      // Only admins can read notification logs for now
      // (expand this later when notification preferences UI is added)
      allow read: if request.auth != null && isAdmin(request.auth.uid);
    }

    // ============================================================================
    // CAPTURA STATS COLLECTIONS
    // ============================================================================
    
    // Captura Order Batches - Stores detailed order data in batches
    match /capturaOrderBatches/{dateStr} {
      // Admins can read order batches from their organization
      allow read: if request.auth != null && 
                     isAdmin(request.auth.uid);
      
      // Only Cloud Functions can write order batches
      allow write: if false;
      
      // Batches subcollection
      match /batches/{batchId} {
        // Admins can read batch data
        allow read: if request.auth != null && 
                       isAdmin(request.auth.uid);
        
        // Only Cloud Functions can write batch data
        allow write: if false;
      }
      
      // Summary subcollection
      match /summary/{summaryType} {
        // Admins can read summary data
        allow read: if request.auth != null && 
                       isAdmin(request.auth.uid);
        
        // Only Cloud Functions can write summary data
        allow write: if false;
      }
    }
    
    // Captura Order Stats - Pre-calculated statistics
    match /capturaOrderStats/{statType} {
      // Admins can read stats
      allow read: if request.auth != null && 
                     isAdmin(request.auth.uid);
      
      // Only Cloud Functions can write stats
      allow write: if false;
      
      // Yearly stats subcollection
      match /{year}/{document=**} {
        // Admins can read yearly stats
        allow read: if request.auth != null && 
                       isAdmin(request.auth.uid);
        
        // Only Cloud Functions can write
        allow write: if false;
      }
    }
    
    // Captura Order Sync Status - Track sync operations
    match /capturaOrderSyncStatus/{statusDoc} {
      // Admins can read sync status
      allow read: if request.auth != null && 
                     isAdmin(request.auth.uid);
      
      // Only Cloud Functions can write sync status
      allow write: if false;
      
      // Sync history logs
      match /logs/{logId} {
        // Admins can read sync logs
        allow read: if request.auth != null && 
                       isAdmin(request.auth.uid);
        
        // Only Cloud Functions can write logs
        allow write: if false;
      }
    }

    // Deny all other documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}