rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to get user's organization ID
    function getUserOrg(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.organizationID;
    }
    
    // Helper function to get user's role
    function getUserRole(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.role;
    }
    
    // Helper function to check if user is admin
    function isAdmin(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.role == 'admin';
    }
    
    // Helper function to check if user is admin or manager
    function isAdminOrManager(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      let role = userDoc.data.role;
      return role == 'admin' || role == 'manager';
    }
    
    // Helper function to check if user belongs to same organization
    function belongsToSameOrg(userId, orgId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.organizationID == orgId;
    }
    
    // Helper function to validate PTO document ID format and ownership
    function isValidPTODocumentAccess(balanceId, userId) {
      // Check if document ID follows pattern: orgId_userId
      let idParts = balanceId.split('_');
      return idParts.size() == 2 && idParts[1] == userId;
    }
    
    // Helper function to check if user is a participant in a conversation
    function isConversationParticipant(userId, conversationDoc) {
      return userId in conversationDoc.data.participants;
    }
    

    // Organizations collection
    match /organizations/{orgId} {
      // Users can read their own organization
      allow read: if request.auth != null && belongsToSameOrg(request.auth.uid, orgId);
      
      // **INVITATION FLOW: Allow reading specific organization for invitation display**
      // This is needed when showing organization name on invitation acceptance page
      allow read: if request.auth == null || request.auth != null;
      
      // Only authenticated users can create organizations (during studio signup)
      allow create: if request.auth != null;
      
      // Only admins can update their organization
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, orgId) && 
                       isAdmin(request.auth.uid) &&
                       // Validate PTO settings if being updated
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['ptoSettings']) ||
                        (request.resource.data.ptoSettings is map &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['enabled']) || request.resource.data.ptoSettings.enabled is bool) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['accrualRate']) || request.resource.data.ptoSettings.accrualRate is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['accrualPeriod']) || request.resource.data.ptoSettings.accrualPeriod is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['maxAccrual']) || request.resource.data.ptoSettings.maxAccrual is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['rolloverPolicy']) || request.resource.data.ptoSettings.rolloverPolicy in ['none', 'unlimited', 'limited']) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['rolloverLimit']) || request.resource.data.ptoSettings.rolloverLimit is number) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['resetDate']) || request.resource.data.ptoSettings.resetDate is string) &&
                         (!request.resource.data.ptoSettings.keys().hasAny(['yearlyAllotment']) || request.resource.data.ptoSettings.yearlyAllotment is number)));
      
      // No deletes allowed
      allow delete: if false;
    }

    // Users collection
    match /users/{userId} {
      // Users can read their own profile
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Users in same organization can read each other (for team management)
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // **INVITATION FLOW: Allow reading inactive users for invitation lookup**
      allow read: if resource.data.isActive == false;
      
      // **INVITATION FLOW: Allow reading temporary invite documents**
      allow read: if resource.data.keys().hasAny(['isTemporaryInvite']) && 
                     resource.data.isTemporaryInvite == true;
      
      // Users can create their own profile (during signup)
      allow create: if request.auth != null && request.auth.uid == userId;
      
      // **INVITATION FLOW: Admins can create temporary invite documents**
      allow create: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       (
                         // Regular user creation (document ID matches Firebase UID)
                         userId == request.auth.uid ||
                         // Temporary invite creation (document ID starts with "invite_")
                         (userId.matches('invite_.*') &&
                          request.resource.data.isTemporaryInvite == true &&
                          request.resource.data.isActive == false &&
                          request.resource.data.keys().hasAll(['email', 'firstName', 'lastName', 'role', 'organizationID', 'isTemporaryInvite', 'isActive']))
                       );
      
      // **INVITATION FLOW: Allow creating new user document during acceptance**
      allow create: if request.auth != null && 
                       request.auth.uid == userId &&
                       // This is a new Firebase Auth user accepting an invitation
                       request.resource.data.isActive == true &&
                       (!request.resource.data.keys().hasAny(['isTemporaryInvite']) || 
                        request.resource.data.isTemporaryInvite == false);
      
      // Users can update their own profile
      allow update: if request.auth != null && 
                       request.auth.uid == userId &&
                       // Prevent users from changing their own role or organizationID
                       request.resource.data.role == resource.data.role &&
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // Admins can update users in their organization
      allow update: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // **INVITATION FLOW: Allow activating inactive invitations (legacy support)**
      allow update: if request.auth != null &&
                       resource.data.isActive == false &&
                       request.resource.data.isActive == true &&
                       // Prevent changing critical fields during activation
                       request.resource.data.role == resource.data.role &&
                       request.resource.data.organizationID == resource.data.organizationID &&
                       request.resource.data.email == resource.data.email &&
                       request.resource.data.firstName == resource.data.firstName &&
                       request.resource.data.lastName == resource.data.lastName;
      
      // **INVITATION FLOW: Allow deleting temporary invite documents**
      allow delete: if request.auth != null &&
                       userId.matches('invite_.*') &&
                       resource.data.isTemporaryInvite == true &&
                       (
                         // During acceptance process (any authenticated user can delete temp invite they're accepting)
                         true ||
                         // Admins can delete temporary invites (cleanup)
                         (isAdmin(request.auth.uid) &&
                          belongsToSameOrg(request.auth.uid, resource.data.organizationID))
                       );
    }

    // Sessions collection
    match /sessions/{sessionId} {
      // Users can read sessions from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create sessions for their organization
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users assigned to the session can update it
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (isAdminOrManager(request.auth.uid) ||
                        // Check if user is one of the assigned photographers
                        (resource.data.keys().hasAny(['photographers']) && 
                         request.auth.uid in resource.data.photographers.map(['id'])) ||
                        // Legacy support for single photographer format
                        (resource.data.keys().hasAny(['photographer']) && 
                         request.auth.uid == resource.data.photographer.id));
      
      // Admins/Managers can update any session in their organization
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Allow job box assignment updates by any user in the organization
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Only allow updating job box assignment fields
                       request.resource.data.keys().difference(resource.data.keys()).hasOnly(['hasJobBoxAssigned', 'jobBoxRecordId']) &&
                       // Validate field types and values
                       request.resource.data.hasJobBoxAssigned is bool &&
                       (request.resource.data.jobBoxRecordId == null || 
                        request.resource.data.jobBoxRecordId is string) &&
                       // Prevent changing other session data
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // Admins can delete sessions
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Daily Job Reports collection
    match /dailyJobReports/{reportId} {
      // Users can read their own reports by userId
      allow read: if request.auth != null && 
                     resource.data.userId == request.auth.uid;
      
      // Users can read reports from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create reports for their organization
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users can update their own reports
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (resource.data.keys().hasAny(['yourName']) && 
                        resource.data.yourName == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.displayName);
      
      // Admins/Managers can update any report in their organization
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can delete their own reports
      allow delete: if request.auth != null && 
                       resource.data.userId == request.auth.uid &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins can delete any report in their organization
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Schools collection
    match /schools/{schoolId} {
      // Users can read schools from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins/Managers can create schools
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users can add location photos to schools in their organization
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Only allow updating the locationPhotos field
                       request.resource.data.keys().difference(resource.data.keys()).hasOnly(['locationPhotos']) &&
                       // Ensure locationPhotos is an array
                       request.resource.data.locationPhotos is list;
      
      // Admins/Managers can update schools
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins can delete schools (soft delete recommended)
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Sports Jobs collection
    match /sportsJobs/{jobId} {
      // Users can read sports jobs from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create sports jobs for their organization
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users assigned to the job can update it
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (resource.data.keys().hasAny(['photographer']) && 
                        resource.data.photographer == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.displayName);
      
      // Admins/Managers can update any sports job in their organization
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins can delete sports jobs
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Sports Jobs Locks subcollection for entry-level locking
    match /sportsJobs/{jobId}/locks/{lockId} {
      // Allow authenticated users to read/write locks for sports jobs in their organization
      // This enables the entry locking system to prevent simultaneous editing conflicts
      allow read, write: if request.auth != null && 
                           request.auth.uid != null &&
                           // Ensure user belongs to the same organization as the parent sports job
                           belongsToSameOrg(request.auth.uid, get(/databases/$(database)/documents/sportsJobs/$(jobId)).data.organizationID);
    }

    // Player Search Index collection
    match /playerSearchIndex/{indexId} {
      // Users can read search index from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Only allow system/cloud functions to write to search index
      allow write: if false;
    }

    // Job Boxes collection
    match /jobBoxes/{boxId} {
      // Users can read job boxes from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create/update job boxes for their organization
      allow create, update: if request.auth != null && 
                               belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Admins can delete job boxes
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // SD Cards collection
    match /sdCards/{cardId} {
      // Users can read SD cards from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create/update SD cards for their organization
      allow create, update: if request.auth != null && 
                               belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Admins can delete SD cards
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Records collection (general records)
    match /records/{recordId} {
      // Users can read records from their organization (if organizationID exists)
      allow read: if request.auth != null && 
                     (!resource.data.keys().hasAny(['organizationID']) || 
                      belongsToSameOrg(request.auth.uid, resource.data.organizationID));
      
      // Users can create records
      allow create: if request.auth != null;
      
      // Users can update their own records or admins can update any
      allow update: if request.auth != null && 
                       (resource.data.keys().hasAny(['createdBy']) && 
                        request.auth.uid == resource.data.createdBy ||
                        isAdmin(request.auth.uid));
      
      // Admins can delete records
      allow delete: if request.auth != null && isAdmin(request.auth.uid);
    }

    // Report Templates collection (for custom daily report templates)
    match /reportTemplates/{templateId} {
      // Users can read templates from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins/Managers can create templates
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Ensure required fields are present
                       request.resource.data.keys().hasAll(['name', 'organizationID', 'fields', 'isActive']) &&
                       // Validate data types
                       request.resource.data.name is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.fields is list &&
                       request.resource.data.isActive is bool &&
                       // Validate shootType if present
                       (!request.resource.data.keys().hasAny(['shootType']) || request.resource.data.shootType is string) &&
                       // Validate version if present
                       (!request.resource.data.keys().hasAny(['version']) || request.resource.data.version is int) &&
                       // Validate isDefault if present
                       (!request.resource.data.keys().hasAny(['isDefault']) || request.resource.data.isDefault is bool);
      
      // Admins/Managers can update templates
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID &&
                       // Validate required fields still present
                       request.resource.data.keys().hasAll(['name', 'organizationID', 'fields', 'isActive']) &&
                       // Validate data types
                       request.resource.data.name is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.fields is list &&
                       request.resource.data.isActive is bool;
      
      // Admins can delete templates
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Time Entries collection (for clock in/out tracking)
    match /timeEntries/{entryId} {
      // Users can read time entries from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create their own time entries
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.userId &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['userId', 'organizationID', 'clockInTime', 'date', 'status']) &&
                       // Validate data types
                       request.resource.data.userId is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.clockInTime is timestamp &&
                       request.resource.data.date is string &&
                       request.resource.data.status in ['clocked-in', 'clocked-out'] &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['sessionId']) || request.resource.data.sessionId is string) &&
                       (!request.resource.data.keys().hasAny(['clockOutTime']) || request.resource.data.clockOutTime is timestamp) &&
                       (!request.resource.data.keys().hasAny(['notes']) || request.resource.data.notes is string);
      
      // Users can update their own time entries (for clock out and editing completed entries)
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.userId &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing core identity fields
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.organizationID == resource.data.organizationID &&
                       (
                         // Allow clock out operations (clockInTime and date unchanged)
                         (request.resource.data.clockInTime == resource.data.clockInTime &&
                          request.resource.data.date == resource.data.date) ||
                         // Allow editing completed entries (can change times and date, but must be completed)
                         (resource.data.status == 'clocked-out' &&
                          request.resource.data.status == 'clocked-out' &&
                          // Validate reasonable working hours (max 16 hours)
                          request.resource.data.clockOutTime > request.resource.data.clockInTime &&
                          (request.resource.data.clockOutTime.toMillis() - request.resource.data.clockInTime.toMillis()) <= 57600000 && // 16 hours in milliseconds
                          // Validate data types for edited fields
                          request.resource.data.clockInTime is timestamp &&
                          request.resource.data.clockOutTime is timestamp &&
                          request.resource.data.date is string &&
                          (!request.resource.data.keys().hasAny(['notes']) || request.resource.data.notes is string) &&
                          (!request.resource.data.keys().hasAny(['sessionId']) || request.resource.data.sessionId is string))
                       );
      
      // Admins/Managers can create and update any time entries in their organization
      allow create, update: if request.auth != null && 
                               isAdminOrManager(request.auth.uid) &&
                               belongsToSameOrg(request.auth.uid, request.resource.data.organizationID);
      
      // Users can delete their own time entries, admins can delete any
      allow delete: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (
                         // Users can delete their own entries
                         request.auth.uid == resource.data.userId ||
                         // Admins can delete any entry in their organization
                         isAdmin(request.auth.uid)
                       );
    }

    // Time Off Requests collection
    match /timeOffRequests/{requestId} {
      // Users can read time off requests from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Users can create their own time off requests
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.photographerId &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationID', 'photographerId', 'photographerName', 'startDate', 'endDate', 'reason', 'status']) &&
                       // Validate data types
                       request.resource.data.organizationID is string &&
                       request.resource.data.photographerId is string &&
                       request.resource.data.photographerName is string &&
                       request.resource.data.startDate is timestamp &&
                       request.resource.data.endDate is timestamp &&
                       request.resource.data.reason is string &&
                       request.resource.data.status == 'pending' &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['notes']) || request.resource.data.notes is string) &&
                       // Validate priority fields
                       (!request.resource.data.keys().hasAny(['priority']) || request.resource.data.priority in ['normal', 'high']) &&
                       (!request.resource.data.keys().hasAny(['priorityReason']) || request.resource.data.priorityReason is string) &&
                       (!request.resource.data.keys().hasAny(['bypassedBlockedDates']) || request.resource.data.bypassedBlockedDates is bool) &&
                       (!request.resource.data.keys().hasAny(['blockedDatesAcknowledged']) || request.resource.data.blockedDatesAcknowledged is bool) &&
                       // Validate PTO fields
                       (!request.resource.data.keys().hasAny(['isPaidTimeOff']) || request.resource.data.isPaidTimeOff is bool) &&
                       (!request.resource.data.keys().hasAny(['ptoHoursRequested']) || 
                        (request.resource.data.ptoHoursRequested is number && 
                         request.resource.data.ptoHoursRequested >= 0 && 
                         request.resource.data.ptoHoursRequested <= 8)) &&
                       // If using PTO, hours must be specified
                       ((!request.resource.data.keys().hasAny(['isPaidTimeOff']) || !request.resource.data.isPaidTimeOff) || 
                        (request.resource.data.keys().hasAny(['ptoHoursRequested']) && request.resource.data.ptoHoursRequested > 0)) &&
                       // If high priority, priorityReason must be provided
                       ((!request.resource.data.keys().hasAny(['priority']) || request.resource.data.priority == 'normal') || 
                        (request.resource.data.priority == 'high' && request.resource.data.keys().hasAny(['priorityReason']) && request.resource.data.priorityReason is string));
      
      // Users can update their own pending requests (to cancel or edit)
      // Admins/Managers can update any request (to approve/deny)
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       (
                         // Users can update their own pending requests
                         (request.auth.uid == resource.data.photographerId && 
                          resource.data.status == 'pending' &&
                          // Prevent changing core fields
                          request.resource.data.photographerId == resource.data.photographerId &&
                          request.resource.data.organizationID == resource.data.organizationID) ||
                         // Admins/Managers can approve/deny/mark as under review
                         (isAdminOrManager(request.auth.uid) &&
                          // Validate approval fields
                          ((request.resource.data.status == 'approved' && 
                           request.resource.data.keys().hasAll(['approvedBy', 'approverName', 'approvedAt']) &&
                           request.resource.data.approvedBy is string &&
                           request.resource.data.approverName is string &&
                           request.resource.data.approvedAt is timestamp) ||
                          // Validate denial fields
                          (request.resource.data.status == 'denied' && 
                           request.resource.data.keys().hasAll(['deniedBy', 'denierName', 'deniedAt', 'denialReason']) &&
                           request.resource.data.deniedBy is string &&
                           request.resource.data.denierName is string &&
                           request.resource.data.deniedAt is timestamp &&
                           request.resource.data.denialReason is string) ||
                          // Validate under review fields
                          (request.resource.data.status == 'under_review' && 
                           request.resource.data.keys().hasAll(['reviewedBy', 'reviewerName', 'reviewedAt']) &&
                           request.resource.data.reviewedBy is string &&
                           request.resource.data.reviewerName is string &&
                           request.resource.data.reviewedAt is timestamp) ||
                          // Allow cancelled status
                          request.resource.data.status == 'cancelled'))
                       );
      
      // Only admins can delete time off requests
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Workflow Templates collection
    match /workflowTemplates/{templateId} {
      // Users can read workflow templates from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Admins/Managers can create workflow templates
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['name', 'organizationID', 'steps', 'isActive']) &&
                       // Validate data types
                       request.resource.data.name is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.steps is list &&
                       request.resource.data.isActive is bool &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['description']) || request.resource.data.description is string) &&
                       (!request.resource.data.keys().hasAny(['sessionTypes']) || request.resource.data.sessionTypes is list) &&
                       (!request.resource.data.keys().hasAny(['trackingTypes']) || request.resource.data.trackingTypes is list) &&
                       (!request.resource.data.keys().hasAny(['estimatedDays']) || request.resource.data.estimatedDays is number) &&
                       (!request.resource.data.keys().hasAny(['isDefault']) || request.resource.data.isDefault is bool) &&
                       (!request.resource.data.keys().hasAny(['version']) || request.resource.data.version is number);
      
      // Admins/Managers can update workflow templates
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID;
      
      // Admins can delete workflow templates (soft delete - set isActive: false)
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Workflows collection (workflow instances)
    match /workflows/{workflowId} {
      // Users can read workflows from their organization
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // System can create workflows (auto-created when sessions complete)
      // Admins/Managers can also manually create workflows
      // Supports both session-based workflows and tracking workflows
      allow create: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Common required fields
                       request.resource.data.keys().hasAll(['organizationID', 'templateId', 'stepProgress']) &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.templateId is string &&
                       request.resource.data.stepProgress is map &&
                       (
                         // Session-based workflow validation
                         (request.resource.data.keys().hasAll(['sessionId']) &&
                          request.resource.data.sessionId is string &&
                          (!request.resource.data.keys().hasAny(['workflowType']) || 
                           request.resource.data.workflowType != 'tracking')) ||
                         // Tracking workflow validation
                         (request.resource.data.keys().hasAll(['schoolId', 'trackingTemplateId', 'academicYear', 'workflowType']) &&
                          request.resource.data.schoolId is string &&
                          request.resource.data.trackingTemplateId is string &&
                          request.resource.data.academicYear is string &&
                          request.resource.data.workflowType == 'tracking' &&
                          (!request.resource.data.keys().hasAny(['trackingStartDate']) || request.resource.data.trackingStartDate is string) &&
                          (!request.resource.data.keys().hasAny(['trackingEndDate']) || request.resource.data.trackingEndDate is string) &&
                          (!request.resource.data.keys().hasAny(['schoolName']) || request.resource.data.schoolName is string))
                       ) &&
                       // Validate optional fields (common to both types)
                       (!request.resource.data.keys().hasAny(['status']) || request.resource.data.status in ['active', 'completed', 'on_hold', 'cancelled', 'deleted']) &&
                       (!request.resource.data.keys().hasAny(['templateName']) || request.resource.data.templateName is string) &&
                       (!request.resource.data.keys().hasAny(['templateVersion']) || request.resource.data.templateVersion is number) &&
                       (!request.resource.data.keys().hasAny(['currentStep']) || request.resource.data.currentStep is string);
      
      // Granular step-level permissions for workflow updates
      allow update: if request.auth != null && 
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing core identity fields
                       request.resource.data.organizationID == resource.data.organizationID &&
                       request.resource.data.templateId == resource.data.templateId &&
                       (
                         // Session-based workflow: prevent changing sessionId
                         (resource.data.keys().hasAny(['sessionId']) &&
                          request.resource.data.sessionId == resource.data.sessionId) ||
                         // Tracking workflow: prevent changing tracking identity fields
                         (resource.data.workflowType == 'tracking' &&
                          request.resource.data.schoolId == resource.data.schoolId &&
                          request.resource.data.trackingTemplateId == resource.data.trackingTemplateId &&
                          request.resource.data.academicYear == resource.data.academicYear &&
                          request.resource.data.workflowType == resource.data.workflowType)
                       ) &&
                       (
                         // Admins/Managers can update any workflow
                         isAdminOrManager(request.auth.uid) ||
                         // Regular users can update workflows (simplified for now)
                         // TODO: Add granular step-level permissions in future iteration
                         true
                       );
      
      // Admins can delete workflows
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // Blocked Dates collection (for blocking time off requests)
    match /blockedDates/{blockedDateId} {
      // Users in the same organization can read blocked dates
      allow read: if request.auth != null && 
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Only admins and managers can create blocked dates
      allow create: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['organizationID', 'startDate', 'endDate', 'reason', 'createdBy', 'createdAt', 'allowHighPriority']) &&
                       // Validate data types
                       request.resource.data.organizationID is string &&
                       request.resource.data.startDate is timestamp &&
                       request.resource.data.endDate is timestamp &&
                       request.resource.data.reason is string &&
                       request.resource.data.createdBy is string &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.allowHighPriority is bool &&
                       // Ensure end date is after start date
                       request.resource.data.endDate > request.resource.data.startDate;
      
      // Only admins and managers can update blocked dates
      allow update: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing organizationID
                       request.resource.data.organizationID == resource.data.organizationID &&
                       // Validate data types if fields are being updated
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['startDate']) || request.resource.data.startDate is timestamp) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['endDate']) || request.resource.data.endDate is timestamp) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['reason']) || request.resource.data.reason is string) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['allowHighPriority']) || request.resource.data.allowHighPriority is bool) &&
                       // Ensure end date is after start date
                       request.resource.data.endDate > request.resource.data.startDate;
      
      // Only admins and managers can delete blocked dates
      allow delete: if request.auth != null && 
                       isAdminOrManager(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // ============================================================================
    // PRODUCTION-READY PTO BALANCES COLLECTION
    // ============================================================================
    match /ptoBalances/{balanceId} {
      // PRODUCTION PTO READ RULES - Handles both existing and non-existent documents
      allow read: if request.auth != null && 
                     (
                       // Case 1: Document exists - validate user belongs to same organization
                       (resource != null && 
                        resource.data.keys().hasAny(['organizationID']) &&
                        belongsToSameOrg(request.auth.uid, resource.data.organizationID)) ||
                       
                       // Case 2: Document doesn't exist - validate predictable ID format and ownership
                       (resource == null && 
                        isValidPTODocumentAccess(balanceId, request.auth.uid)) ||
                       
                       // Case 3: Admin access - admins can read any PTO balance in their organization
                       (resource != null && 
                        resource.data.keys().hasAny(['organizationID']) &&
                        isAdmin(request.auth.uid) && 
                        belongsToSameOrg(request.auth.uid, resource.data.organizationID))
                     );
      
      // PRODUCTION PTO CREATE RULES - Auto-creation of balance documents
      allow create: if (request.auth != null && 
                       // Validate document ID follows predictable format
                       isValidPTODocumentAccess(balanceId, request.auth.uid) &&
                       // Validate user belongs to organization being created
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID)) ||
                       // Allow Cloud Functions to create PTO balance documents
                       (request.auth == null) &&
                       // Validate required fields are present
                       request.resource.data.keys().hasAll(['userId', 'organizationID']) &&
                       // Validate core field types
                       request.resource.data.userId is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.userId == request.auth.uid &&
                       // Validate optional numeric fields (must be numbers if present)
                       (!request.resource.data.keys().hasAny(['currentBalance']) || 
                        (request.resource.data.currentBalance is number && request.resource.data.currentBalance >= 0)) &&
                       (!request.resource.data.keys().hasAny(['pendingBalance']) || 
                        (request.resource.data.pendingBalance is number && request.resource.data.pendingBalance >= 0)) &&
                       (!request.resource.data.keys().hasAny(['usedThisYear']) || 
                        (request.resource.data.usedThisYear is number && request.resource.data.usedThisYear >= 0)) &&
                       (!request.resource.data.keys().hasAny(['earnedThisYear']) || 
                        (request.resource.data.earnedThisYear is number && request.resource.data.earnedThisYear >= 0)) &&
                       (!request.resource.data.keys().hasAny(['bankingBalance']) || 
                        (request.resource.data.bankingBalance is number && request.resource.data.bankingBalance >= 0)) &&
                       // Validate optional timestamp fields
                       (!request.resource.data.keys().hasAny(['lastAccrualDate']) || 
                        request.resource.data.lastAccrualDate is timestamp || request.resource.data.lastAccrualDate == null) &&
                       (!request.resource.data.keys().hasAny(['lastResetDate']) || 
                        request.resource.data.lastResetDate is timestamp || request.resource.data.lastResetDate == null) &&
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt is timestamp) &&
                       (!request.resource.data.keys().hasAny(['updatedAt']) || 
                        request.resource.data.updatedAt is timestamp);
      
      // PRODUCTION PTO UPDATE RULES - Balance updates and accrual
      allow update: if (request.auth != null && 
                       // Validate user belongs to same organization
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID) &&
                       // Prevent changing core identity fields
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.organizationID == resource.data.organizationID &&
                       (
                         // Case 1: User updating their own balance (for accrual, reservations, usage)
                         (resource.data.userId == request.auth.uid &&
                          // Validate numeric fields are valid if being updated
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['totalBalance']) || 
                           (request.resource.data.totalBalance is number && request.resource.data.totalBalance >= 0)) &&
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['pendingBalance']) || 
                           (request.resource.data.pendingBalance is number && request.resource.data.pendingBalance >= 0)) &&
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['usedThisYear']) || 
                           (request.resource.data.usedThisYear is number && request.resource.data.usedThisYear >= 0)) &&
                          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['bankingBalance']) || 
                           (request.resource.data.bankingBalance is number && request.resource.data.bankingBalance >= 0))) ||
                         
                         // Case 2: Admin making manual adjustments
                         (isAdmin(request.auth.uid) &&
                          belongsToSameOrg(request.auth.uid, resource.data.organizationID))
                       )) ||
                       // Case 3: Cloud Functions automatic processing
                       (request.auth == null &&
                        // Validate core identity fields don't change
                        request.resource.data.userId == resource.data.userId &&
                        request.resource.data.organizationID == resource.data.organizationID);
      
      // PRODUCTION PTO DELETE RULES - Only admins can delete (for cleanup)
      allow delete: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, resource.data.organizationID);
    }

    // ============================================================================
    // PRODUCTION-READY PTO ADJUSTMENTS COLLECTION (Audit Trail)
    // ============================================================================
    match /ptoAdjustments/{adjustmentId} {
      // Only admins and managers can read adjustment history
      allow read: if request.auth != null && 
                     isAdminOrManager(request.auth.uid) &&
                     belongsToSameOrg(request.auth.uid, resource.data.organizationID);
      
      // Only admins can create manual PTO adjustments
      allow create: if request.auth != null && 
                       isAdmin(request.auth.uid) &&
                       belongsToSameOrg(request.auth.uid, request.resource.data.organizationID) &&
                       // Validate required fields for audit trail
                       request.resource.data.keys().hasAll(['userId', 'organizationID', 'adjustment', 'reason', 'adminId', 'previousBalance', 'newBalance']) &&
                       // Validate field types
                       request.resource.data.userId is string &&
                       request.resource.data.organizationID is string &&
                       request.resource.data.adjustment is number &&
                       request.resource.data.reason is string &&
                       request.resource.data.adminId == request.auth.uid &&
                       request.resource.data.previousBalance is number &&
                       request.resource.data.newBalance is number &&
                       request.resource.data.previousBalance >= 0 &&
                       request.resource.data.newBalance >= 0 &&
                       // Validate timestamps
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt is timestamp);
      
      // No updates or deletes allowed (immutable audit trail)
      allow update, delete: if false;
    }

    // ============================================================================
    // CHAT SYSTEM - CONVERSATIONS AND MESSAGES
    // ============================================================================
    
    // Conversations collection
    match /conversations/{conversationId} {
      // Users can read conversations they participate in
      allow read: if request.auth != null && 
                     request.auth.uid in resource.data.participants;
      
      // Users can create conversations they participate in
      allow create: if request.auth != null && 
                       // User must be in participants list
                       request.auth.uid in request.resource.data.participants &&
                       // Validate required fields (only essential ones)
                       request.resource.data.keys().hasAll(['participants', 'type']) &&
                       // Validate data types
                       request.resource.data.participants is list &&
                       request.resource.data.type in ['direct', 'group'] &&
                       // Validate participants list includes current user
                       request.resource.data.participants.size() >= 2 &&
                       request.resource.data.participants.size() <= 50 &&
                       request.auth.uid in request.resource.data.participants &&
                       // Validate optional timestamp fields (allow server timestamps)
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == request.time)) &&
                       (!request.resource.data.keys().hasAny(['lastActivity']) || 
                        (request.resource.data.lastActivity is timestamp || request.resource.data.lastActivity == request.time)) &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['name']) || 
                        (request.resource.data.name is string || request.resource.data.name == null)) &&
                       (!request.resource.data.keys().hasAny(['defaultName']) || request.resource.data.defaultName is string) &&
                       (!request.resource.data.keys().hasAny(['lastMessage']) || 
                        (request.resource.data.lastMessage is map || request.resource.data.lastMessage == null)) &&
                       (!request.resource.data.keys().hasAny(['unreadCounts']) || request.resource.data.unreadCounts is map);
      
      // Participants can update conversation metadata (last message, activity, unread counts)
      allow update: if request.auth != null && 
                       request.auth.uid in resource.data.participants &&
                       // Prevent changing participants list and core fields
                       request.resource.data.participants == resource.data.participants &&
                       request.resource.data.type == resource.data.type &&
                       (!resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt == resource.data.createdAt) &&
                       // Allow updating activity and message-related fields (with server timestamps)
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['lastActivity']) || 
                        (request.resource.data.lastActivity is timestamp || request.resource.data.lastActivity == request.time)) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['lastMessage']) || 
                        (request.resource.data.lastMessage is map || request.resource.data.lastMessage == null)) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['unreadCounts']) || 
                        request.resource.data.unreadCounts is map) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['name']) || 
                        (request.resource.data.name is string || request.resource.data.name == null));
      
      // Only admins can delete conversations (for cleanup)
      allow delete: if request.auth != null && isAdmin(request.auth.uid);
    }
    
    // Messages collection (using path: messages/{conversationId}/messages/{messageId})
    match /messages/{conversationId}/messages/{messageId} {
      // Users can read messages from conversations they participate in
      allow read: if request.auth != null && 
                     exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                     request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
      
      // Users can send messages to conversations they participate in
      allow create: if request.auth != null && 
                       exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                       request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                       // User must be the sender
                       request.auth.uid == request.resource.data.senderId &&
                       // Validate required fields (simplified)
                       request.resource.data.keys().hasAll(['senderId', 'text', 'type']) &&
                       // Validate data types
                       request.resource.data.senderId is string &&
                       request.resource.data.text is string &&
                       request.resource.data.type is string &&
                       // Validate optional timestamp fields (allow server timestamps)
                       (!request.resource.data.keys().hasAny(['timestamp']) || 
                        (request.resource.data.timestamp is timestamp || request.resource.data.timestamp == request.time)) &&
                       (!request.resource.data.keys().hasAny(['createdAt']) || 
                        (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == request.time)) &&
                       // Validate optional fields
                       (!request.resource.data.keys().hasAny(['fileUrl']) || 
                        (request.resource.data.fileUrl is string || request.resource.data.fileUrl == null)) &&
                       // Validate text length
                       request.resource.data.text.size() <= 2000;
      
      // Message senders can update their own messages (for editing)
      allow update: if request.auth != null && 
                       exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                       request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                       request.auth.uid == resource.data.senderId &&
                       // Prevent changing core fields
                       request.resource.data.senderId == resource.data.senderId &&
                       (!resource.data.keys().hasAny(['timestamp']) || 
                        request.resource.data.timestamp == resource.data.timestamp) &&
                       (!resource.data.keys().hasAny(['createdAt']) || 
                        request.resource.data.createdAt == resource.data.createdAt) &&
                       // Only allow editing text and type
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['text']) || 
                        (request.resource.data.text is string && request.resource.data.text.size() <= 2000)) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['type']) || 
                        request.resource.data.type is string);
      
      // Only admins can delete messages (for moderation)
      allow delete: if request.auth != null && isAdmin(request.auth.uid);
    }

    // Deny all other documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}